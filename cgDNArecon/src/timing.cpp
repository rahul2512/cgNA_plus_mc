/*
 * Copyright 2015 Jaroslaw Glowacki
 * jarek (dot) glowacki (at) gmail (dot) com
 *
 * This file is part of cgDNArecon.
 *
 * cgDNArecon is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Foobar is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with Foobar.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * @file
 * A simple binary for performance tests
 */

#include<cstdlib>
#include<sys/time.h>

#include<iostream>
#include<iomanip>
#include<vector>

#include<algebra3d/global.h>
#include<algebra3d/Matrix3.h>
#include<algebra3d/Vector3.h>
#include<algebra3d/Quaternion.h>

#include <cgDNArecon/reconstruct.h>

using namespace std;
using namespace algebra3d;
using namespace cgdna_recon;

#ifdef FPTYPE_FLOAT
typedef float fpType;
#else
typedef double fpType;
#endif

/**
 * Returns The number of microseconds from Epoch. This is a simple way of
 * calculating elapsed time with microsecond resolution.
 *
 * @return The number of microseconds from Epoch.
 */
unsigned long long getTime() {
	struct timeval time;
	unsigned long long t;

	gettimeofday(&time, NULL);
	t = time.tv_sec;
	t *= 1000000;
	t += time.tv_usec;

	return t;
}

// A macro for the repetitive code of each timing run
#define RUN(CODE, LABEL) \
		minTime = 1ULL<<60; \
		for (int t = 0; t < numTrials; ++t) { \
			runningTime = getTime(); \
			for (int i = 0; i < numReps; ++i) { \
				for (int t = 0; t < numTests; ++t) { \
					for (int i = 0; i < n; ++i) { \
						shape[i] = shapesCorr[t][i]; \
					} \
					CODE \
				} \
			} \
			runningTime = getTime() - runningTime; \
			if (minTime > runningTime) { \
				minTime = runningTime; \
			} \
		} \
		cout << setw(labelWidth) << LABEL \
			<< setw(timeWidth) << minTime / 1000000.0 << " s" \
			<< endl;

/**
 * Runs the simple performance tests. Test data is taken from a C++ file
 * generated by the Matlab function generateTestData.m.
 *
 * @param argc The number of command line arguments
 * @param argv The command line arguments
 * @return 0 if execution is correct, a positive integer on errors.
 */
int main(int argc, char **argv) {
	unsigned long long minTime;
	unsigned long long runningTime;
	int numReps;
	int numTrials;

	// Include the generated cgDNA configuration data
#define TIMING_ONLY
#include "../test/gen/testData.cpp"
#undef TIMING_ONLY

	int labelWidth = 40;
	int timeWidth = 10;
	int n = 12 * nbp - 6;

	fpType shape[n];

	Vector3<fpType> r1[nbp];
	Vector3<fpType> r2[nbp];
	Quaternion<fpType> D1[nbp];
	Quaternion<fpType> D2[nbp];

	Vector3<fpType> r1m[nbp];
	Vector3<fpType> r2m[nbp];
	Matrix3<fpType> D1m[nbp];
	Matrix3<fpType> D2m[nbp];

	// Check if all required arguments are given
	if (argc != 3) {
		cerr << "Usage:\n"
				"    " << argv[0]
				<< " num_reps\n"
						"Where:\n"
						"    num_reps is the number of repetitions all the Matlab generated data\n"
						"             is to be run\n"
						"    num_trials  is the number of trials to perform to choose the fastest result\n"
				<< endl;
		return 1;
	}

	numReps = atoi(argv[1]);
	numTrials = atoi(argv[2]);

	if (sizeof(fpType) == sizeof(float)) {
		cout << "Single precission test\n" << endl;
	} else {
		cout << "Double precission test\n" << endl;
	}

	cout << "Timing different methods of reconstruction\n" << numReps
			<< " times for " << numTests << " \\hat{w} shapes of random " << nbp
			<< "-mers\n" << "Printing fastest of " << numTrials << " trials"
			<< endl;

#define RECON_Q reconstruct<fpType>(nbp, shape, r1, r2, D1, D2);
	RUN(RECON_Q, "Using quaternions: ")

#define RECON_M reconstructM<fpType>(nbp, shape, r1m, r2m, D1m, D2m);
	RUN(RECON_M, "Using matrices: ")

#define RECON_Q_BP reconstructBP<fpType>(nbp, shape, r1, D1, true);
	RUN(RECON_Q_BP, "Using quaternions (just BP data): ")

#define RECON_M_BP reconstructBPM<fpType>(nbp, shape, r1m, D1m, true);
	RUN(RECON_M_BP, "Using matrices (just BP data): ")

	return 0;
}

