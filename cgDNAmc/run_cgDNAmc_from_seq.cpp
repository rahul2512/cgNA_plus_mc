/*
 * Copyright 2016 Jaroslaw Glowacki
 * jarek (dot) glowacki (at) gmail (dot) com
 *
 * This file is part of cgDNAmc.
 *
 * cgDNAmc is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * cgDNAmc is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with cgDNAmc.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * @file
 * A program to run Monte Carlo simulations of a given DNA fragment using the
 * <a href="http://lcvmwww.epfl.ch/cgDNA">cgDNA</a> nearest neighbour
 * rigid base model (see @ref sec_theory).
 *
 * This code provides a reference of how to use most of the functions of the
 * package (the rest is used by the @ref build_seq_data.cpp).
 *
 * <b>Running simulations</b>
 *
 * In order to run a simulation for a given DNA sequence input data
 * (cgDNA stiffness matrix and shape vector) should be provided in a file
 * formatted appropriate for the @ref load_cgdna_stiff_and_w_hat() function.
 * This data can be produced either by @ref build_seq_data.cpp, or the provided
 * Matlab/Octave script
 * <a href="http://lcvmwww.epfl.ch/cgDNAmc/repo/save_seq_data.m">`save_seq_data.m`</a>.
 * This solution allows for using
 * "non-standard" input data (e.g.. a @f$PD^{-\frac{1}{2}}@f$ factor of the
 * spectral decomposition of the stiffness matrix -- see @ref
 * load_cgdna_stiff_and_w_hat()).
 *
 * To run the binary a number of command line arguments needs to be defined.
 * If run without command line arguments the binary prints usage instructions
 * similar to the following. If not all required arguments are provided the
 * binary prints information about the missing ones. The arguments can be
 * provided in the standard POSIX `getopt` format for command line options:
 *     - `-e` <BR>
 *     <b>required</b> <BR>
 *     the argument of this option is a string of comma-separated requests that
 *     define the expectations to be computed in the run; see
 *     @ref get_requested_expectations() for the format of requests
 *     -  `-l` <BR>
 *     <b>required</b> <BR>
 *     the argument of this option is the label to use in names of generated
 *     files (e.g. codename for the sequence)
 *     -  `-i` <BR>
 *     <b>required</b> <BR>
 *     the argument of this option is a path to a file with the cgDNA parameters for
 *     the DNA sequence are stored; this should be a file generated by
 *     @ref build_seq_data.cpp or using the Matlab/Octave script
 *     <a href="http://lcvmwww.epfl.ch/cgDNAmc/repo/save_seq_data.m">`save_seq_data.m`</a>
 *     that allows to prepare data in a "non-standard" way
 *     (e.g. using eigenvalue decomposition -- see below).
 *     - `-t` <BR>
 *     <b>required</b> <BR>
 *     the argument of this option is describing the way the stiffness matrix is
 *     provided in the `input_data_file` file; this program accepts two values
 *     for the two possibilities:
 *         - `c` -- the stiffness matrix is given as a lower triangular Cholesky
 *         factor in band storage; this is the format generated by
 *         @ref build_seq_data.cpp
 *         (as needed for @ref generate_random_move_band())
 *         - `e` -- the stiffness matrix is given as a spectral decomposition
 *         (eigendecomposition) factor @f$PD^{-\frac{1}{2}}@f$ in full
 *         storage; this can be created e.g. in Matlab/Octave by building the
 *         cgDNA stiffness matrix and shape vector using the cgDNA package
 *         scripts, computing the factor through spectral decomposition in
 *         Matlab/Octave and saved into an appropriate file using the
 *         `save_se_data.m` script provided by this package
 *         (as needed for @ref generate_random_move_spect())
 *     - `-a` <BR>
 *     <b>required</b> (exclusive with `-g`)<BR>
 *     the argument of this option is the requested number of accepted
 *     configurations (the simulation will end when so many configurations are
 *     accepted)
 *     - `-g` <BR>
 *     <b>required</b> (exclusive with `-a`)<BR>
 *     the argument of this option is the requested number of generated
 *     configurations (the simulation will end when so many configurations are
 *     generated)
 *     - `-d` <BR>
 *     <b>required</b> <BR>
 *     the argument of this option is the number @f$d@f$ of base pairs to drop
 *     from either end; the next base pair will be treated as the first one
 *     (index 0); to avoid end effects the recommended value is 10
 *     - `-j` <BR>
 *     <b>required</b> <BR>
 *     the argument of this option is A flag indicating whether the Jacobian
 *     should be used (if Metropolis Monte Carlo should be run):
 *         - `y` -- use Jacobian (run Mertopolis Monte Carlo)
 *         - `n` -- do not use Jacobian (run direct Monte Carlo)
 *     - `-s` <BR>
 *     <b>optional</b> <BR>
 *     if provided the argument of this option is used as the seed of the
 *     pseudo-random number generator (PRNG); if it is not provided seed is
 *     taken from `/dev/urandom` (see @ref get_random_seed()); in any case the
 *     seed used in the simulation is indicated in the log file and in the name
 *     of output files; see the @ref seed_xorshift1024() for a description of
 *     how the provided value is used exactly; it is  recommended not to use this
 *     option and rely on @ref get_random_seed() and `/dev/urandom`; this option
 *     is only useful if one wants to exactly reproduce results of another
 *     simulation.
 *
 * Some examples of using the code are presented to clarify the meaning of the
 * parameters. Example input files used below and generated output files are
 * available in the directory
 * <a href="http://lcvmwww.epfl.ch/software/cgDNAmc/examples">`examples`</a>
 * separately or as a ZIP archive
 * <a href="http://lcvmwww.epfl.ch/software/cgDNAmc/examples/examples.zip">`examples.zip`</a>.
 * The names of the files below are links to those.
 *
 * <b>Example 1</b> <BR>
 * (~50 seconds on a laptop)
 *
 * The following example illustrates a particular use case.
 * If the compiled binary for run_cgDNAmc.cpp is located in the directory
 * `/path/to/cgDNAmc` an example run could be:
 * @verbatim
 $ /path/to/cgDNAmc/run_cgDNAmc  -e t0,s1,r,t1,t11  -l my_seq_run1  -i my_seq_data.txt  -t c  -a 100000  -d 10  -j n
 @endverbatim
 *
 * This simulation run uses cgDNA stiffness matrix and ground state
 * configuration coefficients from the file
 * <a href="http://lcvmwww.epfl.ch/software/cgDNAmc/examples/my_seq_data.txt">`my_seq_data.txt`</a>
 * (generated by the @ref build_seq_data.cpp code for
 * <a href="http://lcvmwww.epfl.ch/software/cgDNAmc/examples/my_seq.txt">`my_seq.txt`</a>).
 * The stiffness
 * matrix is given in band Cholesky storage (`-t c`). The simulation is run
 * until 100000 configurations are accepted. Direct Monte Carlo sampling is used
 * (`-j n` means no Jacobian). The seed for the pseudo-random number generator
 * is automatically chosen (no `-s` option provided, @ref get_random_seed()
 * is used to generate the seed). In the particular case described below the
 * value 5211353839904819223 was chosen, although if the above command is run
 * again a different number is chosen (see Example 2 for how to ensure
 * reproducibility).
 *
 * The same results would be achieved if `-g` was used instead of `-a` with the
 * same number because in Direct Monte Carlo all generated configurations are
 * accepted (see <b>Example 2</b>).
 *
 * The example call creates 10 files:
 *     - <a href="http://lcvmwww.epfl.ch/software/cgDNAmc/examples/my_seq_run1-t0-t1-t11-s1-r_100000a_10_nj_5211353839904819223.log">`my_seq_run1-t0-t1-t11-s1-r_100000a_10_nj_5211353839904819223.log`</a>
 *     -- with details of the run (used parameters, running time etc.)
 *     - <a href="http://lcvmwww.epfl.ch/software/cgDNAmc/examples/my_seq_run1_r_100000a_10_nj_5211353839904819223">`my_seq_run1_r_100000a_10_nj_5211353839904819223`</a>
 *     -- with the computed values of the Flory persistence vectors
 *     @f$\langle {\bf R}_0^T({\bf r}_i - {\bf r}_0) \rangle@f$
 *     (see @ref compute_r); this was requested in this run only as an example;
 *     in reality one would most certainly compute Flory persistence vectors
 *     for much longer sequences (~1'500 base pairs)
 *     - <a href="http://lcvmwww.epfl.ch/software/cgDNAmc/examples/my_seq_run1_s1_100000a_10_nj_5211353839904819223">`my_seq_run1_s1_100000a_10_nj_5211353839904819223`</a>
 *     -- with the computed expected values
 *     @f$\langle {\bf s}^{[1]}_i \rangle@f$ of the arclengths
 *     @f$\widehat{\bf s}^{[1]}_i@f$ (see @ref compute_sk)
 *     - <a href="http://lcvmwww.epfl.ch/software/cgDNAmc/examples/my_seq_run1_s1_intr_10">`my_seq_run1_s1_intr_10`</a>
 *     -- with the values of the arclengths
 *     @f${\bf s}^{[1]}_i@f$ (see @ref compute_sk) computed for the ground state
 *     configuration
 *     - <a href="http://lcvmwww.epfl.ch/software/cgDNAmc/examples/my_seq_run1_t0_100000a_10_nj_5211353839904819223">`my_seq_run1_t0_100000a_10_nj_5211353839904819223`</a>
 *     -- with computed expected values of
 *     tangent-tangent correlations
 *     @f$\langle {\bf t}^{[0]}_0 \cdot {\bf t}^{[0]}_i \rangle@f$ for tangents
 *     @f${\bf t}^{[0]}_i@f$ (see @ref compute_t0)
 *     - <a href="http://lcvmwww.epfl.ch/software/cgDNAmc/examples/my_seq_run1_t0_intr_10">`my_seq_run1_t0_intr_10`</a>
 *     -- with the values of the of tangent-tangent
 *     correlations
 *     @f$\widehat{\bf t}^{[0]}_0 \cdot \widehat{\bf t}^{[0]}_i@f$ for tangents
 *     @f$\widehat{\bf t}^{[0]}_i@f$ (see @ref compute_t0) computed for the
 *     ground state configuration
 *     - <a href="http://lcvmwww.epfl.ch/software/cgDNAmc/examples/my_seq_run1_t1_100000a_10_nj_5211353839904819223">`my_seq_run1_t1_100000a_10_nj_5211353839904819223`</a>
 *     -- with computed expected values of
 *     tangent-tangent correlations
 *     @f$\langle {\bf t}^{[1]}_0 \cdot {\bf t}^{[1]}_i \rangle@f$ for tangents
 *     @f${\bf t}^{[1]}_i@f$ (see @ref compute_t1)
 *     - <a href="http://lcvmwww.epfl.ch/software/cgDNAmc/examples/my_seq_run1_t1_intr_10">`my_seq_run1_t1_intr_10`</a>
 *     -- with the values of the of tangent-tangent
 *     correlations
 *     @f$\widehat{\bf t}^{[1]}_0 \cdot \widehat{\bf t}^{[1]}_i@f$ for tangents
 *     @f$\widehat{\bf t}^{[1]}_i@f$ (see @ref compute_t1) computed for the
 *     ground state configuration
 *     - <a href="http://lcvmwww.epfl.ch/software/cgDNAmc/examples/my_seq_run1_t11_100000a_10_nj_5211353839904819223">`my_seq_run1_t11_100000a_10_nj_5211353839904819223`</a>
 *     -- with computed expected values of
 *     tangent-tangent correlations
 *     @f$\langle {\bf t}^{[11]}_0 \cdot {\bf t}^{[11]}_i \rangle@f$ for tangents
 *     @f${\bf t}^{[11]}_i@f$ (see @ref compute_tk)
 *     - <a href="http://lcvmwww.epfl.ch/software/cgDNAmc/examples/my_seq_run1_t11_intr_10">`my_seq_run1_t11_intr_10`</a>
 *     -- with the values of the of tangent-tangent
 *     correlations
 *     @f$\widehat{\bf t}^{[11]}_0 \cdot \widehat{\bf t}^{[11]}_i@f$ for
 *     tangents @f$\widehat{\bf t}^{[11]}_i@f$ (see @ref compute_tk) computed
 *     for the ground state configuration
 *
 * The `100000a` in the file names indicates the simulation finished at
 * 100000 accepted configurations.
 *
 * The tangent-tangent correlations are written in two columns. The first column
 * is the base pair index @f$i@f$ (starting from 0, with 0 meaning the fist base
 * pair that is not dropped, i.e. 11 for the above run). In the the second
 * column there is the (expectation of) correlation
 * @f${\bf t}^{[k]}_0 \cdot {\bf t}^{[k]}_i@f$.
 *
 * Similar format is adopted for arclength data, namely 2 columns: base pair
 * index and the (expectation of) the arclength.
 *
 * For Flory persistence vectors there are 4 columns: base pair index @f$i@f$ and
 * the three components of the persistence vector
 * @f$\langle {\bf R}_0^T({\bf r}_i - {\bf r}_0) \rangle@f$.
 *
 * Each name of a data file consists of the chosen label (here `my_seq`), an
 * indication of the computed expectation (e.g. `t0`, `s1`, `r`) and a suffix
 * generated by the @ref get_file_suffix() function based on the parameters of
 * the simulation.
 *
 * Each of the above files is updated every 10000 generated configurations so
 * that partial results can be examined for long simulations.
 *
 * <b>Example 2</b> <BR>
 * (~50 seconds on a laptop)
 *
 * The following example run generates exactly the same results as
 * <b>Example 1</b>:
 * @verbatim
 $ /path/to/cgDNAmc/run_cgDNAmc  -e t0,s1,r,t1,t11  -l my_seq_run2  -i my_seq_data.txt  -t c  -g 100000  -d 10  -j n  -s 5211353839904819223
 @endverbatim
 *
 * The only difference is the use of the `-g` option instead
 * of `-a`. The results are the same because Direct Monte Carlo is used and so
 * every generated configuration is accepted. The difference will be that the
 * file names will indicate `100000g` instead of `100000a`. Note also the use of
 * the `-s` option, which ensures the value 5211353839904819223 is used as the
 * seed of the pseudo random number generator and so the simulation will be an
 * exact reproduction of that shown in <b>Example 1</b>. The content of the
 * generated files is the same as in <b>Example 1</b> (of course with the
 * exception of the `.log` file).
 *     - <a href="http://lcvmwww.epfl.ch/software/cgDNAmc/examples/my_seq_run2-t0-t1-t11-s1-r_100000g_10_nj_5211353839904819223.log">`my_seq_run2-t0-t1-t11-s1-r_100000g_10_nj_5211353839904819223.log`</a>
 *     - <a href="http://lcvmwww.epfl.ch/software/cgDNAmc/examples/my_seq_run2_r_100000g_10_nj_5211353839904819223">`my_seq_run2_r_100000g_10_nj_5211353839904819223`</a>
 *     - <a href="http://lcvmwww.epfl.ch/software/cgDNAmc/examples/my_seq_run2_s1_100000g_10_nj_5211353839904819223">`my_seq_run2_s1_100000g_10_nj_5211353839904819223`</a>
 *     - <a href="http://lcvmwww.epfl.ch/software/cgDNAmc/examples/my_seq_run2_s1_intr_10">`my_seq_run2_s1_intr_10`</a>
 *     - <a href="http://lcvmwww.epfl.ch/software/cgDNAmc/examples/my_seq_run2_t0_100000g_10_nj_5211353839904819223">`my_seq_run2_t0_100000g_10_nj_5211353839904819223`</a>
 *     - <a href="http://lcvmwww.epfl.ch/software/cgDNAmc/examples/my_seq_run2_t0_intr_10">`my_seq_run2_t0_intr_10`</a>
 *     - <a href="http://lcvmwww.epfl.ch/software/cgDNAmc/examples/my_seq_run2_t1_100000g_10_nj_5211353839904819223">`my_seq_run2_t1_100000g_10_nj_5211353839904819223`</a>
 *     - <a href="http://lcvmwww.epfl.ch/software/cgDNAmc/examples/my_seq_run2_t1_intr_10">`my_seq_run2_t1_intr_10`</a>
 *     - <a href="http://lcvmwww.epfl.ch/software/cgDNAmc/examples/my_seq_run2_t11_100000g_10_nj_5211353839904819223">`my_seq_run2_t11_100000g_10_nj_5211353839904819223`</a>
 *     - <a href="http://lcvmwww.epfl.ch/software/cgDNAmc/examples/my_seq_run2_t11_intr_10">`my_seq_run2_t11_intr_10`</a>
 *
 * <b>Example 3</b> <BR>
 * (~75 seconds on a laptop)
 *
 * The following example run uses Metropolis Monte Carlo and computes a smaller
 * set of expectations.
 * @verbatim
 $ /path/to/cgDNAmc/run_cgDNAmc  -e t11,s11  -l my_seq_run3  -i my_seq_data.txt  -t c  -a 100000  -d 10  -j y
 @endverbatim
 *
 * The use of Metroppolis Monte Carlo introduces a difference between
 * simulations using the `-a` vs. `-g` option. The difference in results depends
 * on the acceptance rate, as in general not all generated configurations are
 * accepted. For Metropolis MC runs the `-a` option seems more adequate,
 * although the `-g` might be used e.g. to assess the acceptance rate in case of
 * very low values.
 *
 * This run is also not using the `-s` option so the seed for the pseudo random
 * number generator is chosen automatically (4098283362866117121 in the case
 * presented below) and differs between subsequent runs of the command.
 *
 * The files generated by this run are (for example):
 *     - <a href="http://lcvmwww.epfl.ch/software/cgDNAmc/examples/my_seq_run3-t11-s11_100000a_10_j_4098283362866117121.log">`my_seq_run3-t11-s11_100000a_10_j_4098283362866117121.log`</a>
 *     - <a href="http://lcvmwww.epfl.ch/software/cgDNAmc/examples/my_seq_run3_s11_100000a_10_j_4098283362866117121">`my_seq_run3_s11_100000a_10_j_4098283362866117121`</a>
 *     - <a href="http://lcvmwww.epfl.ch/software/cgDNAmc/examples/my_seq_run3_s11_intr_10">`my_seq_run3_s11_intr_10`</a>
 *     - <a href="http://lcvmwww.epfl.ch/software/cgDNAmc/examples/my_seq_run3_t11_100000a_10_j_4098283362866117121">`my_seq_run3_t11_100000a_10_j_4098283362866117121`</a>
 *     - <a href="http://lcvmwww.epfl.ch/software/cgDNAmc/examples/my_seq_run3_t11_intr_10">`my_seq_run3_t11_intr_10`</a>
 *
 * Their content is analogous to those of <b>Example 1</b>
 */

// * The symmetric positive definite stiffness (inverse covariance) matrix
// * @f$K=\Sigma^{-1}@f$ can be given as either:
// * @li a lower triangular factor L from Cholesky decomposition @f$K=LL^{T}@f$
// * in symmetric band storage
// * @li a matrix @f$PD^{-\frac{1}{2}}@f$ that comes from the spectral
// * decomposition
// * @f$K=PDP^T@f$
// * with P orthogonal and D > 0 diagonal.
#include <iostream>
#include <sstream>
#include <fstream>
#include <vector>
#include <string>
#include <set>
#include <cstdio>
#include <cmath>
#include <cstdlib>
// For the standard POSIX getopt function to handle command line options
#include <unistd.h>

/** @cond */
#include <algebra3d/Vector3.h>
#include <algebra3d/Quaternion.h>
#include <cgDNArecon/reconstruct.h>
/** @endcond */

#include <rand.h>
#include <helpers.h>
#include <cgDNAutils.h>

using namespace std;
// Documented in helpers.h
using namespace algebra3d;
/**
 * @namespace cgdna_recon
 * @brief Dependency: Reconstruction of 3D shapes from cgDNA shape coefficients
 *
 * This namespace is defined by the cgDNArecon project at
 * http://lcvmwww.epfl.ch/software/cgDNArecon.
 */
using namespace cgdna_recon;

/**
 * Recovers the information about expectations chosen to be computed in the run.
 * The string @p requests string should provide a comma separated list of
 * requests (no spaces allowed). Each request is of one of the following three
 * forms
 *     - `tX` (where `X` is a non-negative integer) -- a request to compute
 *     expectations of tangent-tangent correlations of @f${\bf t}^{[X]}@f$
 *     (see @ref compute_t0(), @ref compute_t1(), @ref compute_tk())
 *     - `sX` (where `X` is a non-negative integer) -- a request to compute
 *     expectations of arclengths @f${\bf s}^{[X]}@f$
 *     (see @ref compute_sk())
 *     - `r` -- a request to compute the FLory persistence vectors
 *     (see @ref compute_r())
 *
 * Example values of @p requests:
 *     - `t0` -- compute only expectations of tangent-tangent correlations for
 *     @f${\bf t}^{[0]}@f$
 *     - `t0,s1` -- compute expectations of tangent-tangent correlations for
 *     @f${\bf t}^{[0]}@f$ and arclengths @f${\bf s}^{[1]}@f$
 *     - `s11,r,t11` -- compute expectations of tangent-tangent correlations for
 *     @f${\bf t}^{[11]}@f$, arclengths @f${\bf s}^{[11]}@f$ and Flory
 *     persistence vectors
 *
 * @param[in] requests The string containing comma separated requests for
 * expectations to compute
 * @param[out] chosen_t The "indices" of tangents to be computed by the run as
 * retrieved from the @p requests string
 * @param[out] chosen_s The "indices" of arclengths to be computed as
 * retrieved from the @p requests string
 * @param[out] flory_chosen A flag indicating whether Flory persistence vectors
 * are to be computed (`true` if a request found)
 *
 * @return An error code; 0 - success
 */
int get_requested_expectations(const string &requests, vector<int> &chosen_t,
		vector<int> &chosen_s, bool &flory_chosen) {
	set<int> chosen_t_set;
	set<int> chosen_s_set;
	set<int>::iterator it;
	int comma = 0;
	int k;
	char *end;
	string request;
	// For each comma-separated request
	for (int i = 0; comma != -1; i = comma + 1) {
		// Get the request
		comma = requests.find(',', i + 1);
		request = requests.substr(i, comma - i);
		// Validate it and retrieve the k of selected tangent or arclegth
		switch (request[0]) {
		case 't':
			k = strtol(&(request[1]), &end, 0);
			if (end != &(request[request.size()]) || k < 0) {
				return i + 1;
			}
			// Add to a set first to avoid duplicates
			chosen_t_set.insert(k);
			break;
		case 's':
			k = strtol(&(request[1]), &end, 0);
			if (end != &(request[request.size()]) || k < 1) {
				return i + 1;
			}
			// Add to a set first to avoid duplicates
			chosen_s_set.insert(k);
			break;
		case 'r':
			if (request.size() != 1) {
				return i + 1;
			}
			flory_chosen = true;
			break;
		default:
			return i + 1;
		}
	}
	// Copy the data to output arrays
	chosen_t.resize(chosen_t_set.size());
	for (it = chosen_t_set.begin(), k = 0; it != chosen_t_set.end();
			++it, ++k) {
		chosen_t[k] = *it;
	}
	chosen_s.resize(chosen_s_set.size());
	for (it = chosen_s_set.begin(), k = 0; it != chosen_s_set.end();
			++it, ++k) {
		chosen_s[k] = *it;
	}
	return 0;
}

/**
 * Reads and validates the command line arguments of the programme. Prints usage
 * information if wrong number of command line arguments provided.
 *
 * @param[in] argc The number of command line arguments
 * @param[in] argv The command line arguments
 * @param[out] chosen_t The "indices" of tangents to be computed by the run
 * @param[out] chosen_s The "indices" of arclengths to be computed
 * @param[out] flory_chosen A flag indicating whether Flory persistence vector
 * is to be computed
 * @param[out] label The label to be used in file names
 * @param[out] inut_seq_file The file with the DNA sequence to use
 * @param[out] inut_paramset the file with the cgDNA paramset to use
 * @param[out] num_configs_gen The requested number of configurations to generate
 * @param[out] num_configs_acc The requested number of accepted configurations
 * @param[out] use_jac `true` if Jacobian should be used, `false` if not
 * @param[out] num_dropped_bp The number of base pairs to drop from either end
 * @param[out] seed The random number generator seed as required by
 * #init_rand_generator()
 * @return An error code; 0 - success
 */
int handle_command_line(int argc, char **argv, vector<int> &chosen_t,
		vector<int> &chosen_s, bool &flory_chosen, string &label,
		string &inut_seq_file, string &inut_paramset, int &num_configs_gen,
		int &num_configs_acc, bool &use_jac, int &num_dropped_bp, long &seed) {
	// Options for the way stiffness data is provided
	const string STIFF_CHOLESKY_BANDED = "c";
	const string STIFF_EIGEN_FULL = "e";
	// Options for use/don't use Jacobian option
	const string JAC_YES = "y";
	const string JAC_NO = "n";

	string seed_str;
	char *endptr = NULL;

	int c;
	int result;

	// Information for getopt
	// Required options first, optional after (see num_opts_required)
	char options[] = { 'e', // expectations to compute
			'l', // label of the simulation (for file names)
			'i', // input sequence
			'p', // parameter set to use
			'a', // required number of accepted configurations
			'g', // required number of generated configurations
			'd', // dropped base pairs at each end
			'j', // Jacobian (used or not)
			's' // seed for pseudo-random number generator
			};
	string options_msg[] =
			{
					(string(
							"        the argument of this option is a string providing the expectations to\n"
									"        be computed during the simulation; a set of comma-separated request in\n"
									"        any of the thee forms:\n"
									"            tX  (X is a non-neg. integer); a request to compute tangent-tangent\n"
									"                correlations for t^{[X]}\n"
									"            sX  (X is a non-neg. integer); a request to compute arclengths\n"
									"                s^{[X]}\n"
									"            r   request to compute Flory persistence vectors\n"
									"        example:\n"
									"            -") + options[0])
							+ " t0,s0,r,t11\n"
									"        the above options require computation of t^{0}, t^{11}, s^{0}\n"
									"        and Flory persistence vectors\n",
					//
					"        the argument of this option is the label to be used in names of output\n"
							"        file\n",
					//
					"        the argument of this option is a path to a file with the DNA\n"
                             "   sequence for an oligomer to use in the simulation\n",
					//
					"        the argument of this option is a path to a file with the cgDNA\n"
							"        parameter set to use for the reconstruction;\n",
					//
					(string("        (exclusive with -") + options[5])
							+ ")\n"
									"        the argument of this option is the requested number of accepted\n"
									"        configurations (the simulation will end when so many configurations are\n"
									"        accepted)\n",
					//
					(string("        (exclusive with -") + options[4])
							+ ")\n"
									"        the argument of this option is the requested number of generated\n"
									"        configurations (the simulation will end when so many configurations are\n"
									"        generated)\n",
					//
					"        the argument of this option is the number of base pairs dropped at\n"
							"        either end of each generated configuration\n",
					//
					"        the argument of this option defines whether the Jacobian should be used\n"
							"        (Metropolis Monte Carlo) or not (direct sampling)\n"
							"            '" + JAC_YES + "' if yes\n"
							"            '" + JAC_NO + "' if not\n",
					//
					"        the argument of this option is the seed for the pseudo-random number\n"
							"        generator; if not provided a seed is taken from /dev/urandom\n" };
	string optionts_example[] = { "t0,s1,r,t1,t11",
	//
			"my_seq_run1",
			//
			"my_seq.txt",
			//
			"myparamset.txt",
			//
			"100000",
			// -g not printed in the example (empty string)
			"",
			//
			"10",
			//
			"n",
			//
			"" };
	int num_opts = sizeof(options) / sizeof(options[0]);
	// All options are required but the last one
	int num_opts_required = num_opts - 1;
	vector<bool> options_found(num_opts, false);
	string short_opts = "";

	string binary = argv[0];

	// If no arguments provided just show the usage message
	if (argc == 1) {
		print_usage_info(binary, options, num_opts, num_opts_required,
				options_msg, optionts_example);
		return 1;
	}

	// Prepare the options string for getopt
	for (int i = 0; i < num_opts; ++i) {
		short_opts += options[i];
		short_opts += ":";
	}

	// Get the command line options with values
	while (true) {
		c = getopt(argc, argv, short_opts.c_str());
		// Chosen expectations
		if (c == options[0]) {
			result = get_requested_expectations(optarg, chosen_t, chosen_s,
					flory_chosen);
			if (result != 0) {
				// Print to standard error output
				cerr
						<< "Error!\nIncorrect string with requested expectations:\n'"
						<< optarg << "'\nat position " << result
						<< "\n(run the program without arguments to see usage)"
						<< endl;
				return 2;
			}
			// Option provided
			options_found[0] = true;
		}
		// Run label
		else if (c == options[1]) {
			label = optarg;
			// Option provided
			options_found[1] = true;
		}
		// Input sequence file
		else if (c == options[2]) {
			inut_seq_file = optarg;
			// Option provided
			options_found[2] = true;
		}
		// Parameter set file
		else if (c == options[3]) {
            inut_paramset = optarg;
            // Option provided
            options_found[3] = true;
		}
		// Number of configs generated
		else if (c == options[4]) {
			if (options_found[5]) {
				// Print to standard error output
				cerr
						<< "Error!\nThe number of configurations generated and accepted cannot be"
								" requested at the same time\n"
						<< "provide only one of the options: -" << options[4]
						<< " or -" << options[5] << endl;
				return 6;
			}
			num_configs_acc = atoi(optarg);
			// Option provided
			options_found[4] = true;
		}
		// Number of configs accepted
		else if (c == options[5]) {
			if (options_found[4]) {
				// Print to standard error output
				cerr
						<< "Error!\nThe number of configurations generated and accepted cannot be"
								" requested at the same time\n"
						<< "provide only one of -" << options[4] << " or -"
						<< options[5] << endl;
				return 7;
			}
			num_configs_gen = atoi(optarg);
			// Option provided
			options_found[5] = true;
		}
		// Number of dropped base pairs
		else if (c == options[6]) {
			num_dropped_bp = atoi(optarg);
			// Option provided
			options_found[6] = true;
		}
		// Use Jacobian
		else if (c == options[7]) {
			if (string(optarg) == JAC_YES) {
				use_jac = true;
			} else if (string(optarg) == JAC_NO) {
				use_jac = false;
			} else {
				// Print to standard error output
				cerr << "Error!\nIncorrect value of use Jacobian option: '"
						<< optarg
						<< "'\n(run the program without arguments to see usage)"
						<< endl;
				return 9;
			}
			// Option provided
			options_found[7] = true;
		}
		// pseudo-random number generator seed
		else if (c == options[8]) {
			seed_str = optarg;
			seed = strtoll(seed_str.c_str(), &endptr, 0);
			if (endptr != NULL
					&& ((endptr - &(seed_str[0])) != (int) seed_str.length())) {
				// Print to standard error output
				cerr << "Error!\nIncorrect value of PRNG seed provided: '"
						<< seed_str << "'" << endl;
				return 10;
			}
			// Option provided
			options_found[8] = true;
		}
		// Incorrect option argument
		else if (c == -1) {
			break;
		}
		// Unrecognized argument or the end
		else {
			return c;
		}
	}
	// Unrecognized argument
	if (optind < argc) {
		cerr << "Error!\nUnrecognized command line argument: " << endl;
		cerr << argv[optind++] << endl;
		return num_opts + 1;
	}

	// Check requested number of generated and accepted configurations
	if (options_found[4]) {
		num_configs_gen = -1;
		// Only one of the two numbers needs to be defined
		// Mark the other one as defined
		options_found[5] = true;
	} else {
		num_configs_acc = -1;
		if (options_found[5]) {
			// Only one of the two numbers needs to be defined
			// Mark the other one as defined
			options_found[4] = true;
		}
	}

	// Have all arguments been provided?
	if (!check_missing_opts(options, num_opts_required, options_found,
			options_msg)) {
		return num_opts + 2;
	}

	// Success
	return 0;
}

/**
 * Save the current state of MC tangent-tangent correlation computations in a
 * file. Every expectation chosen to be computed is saved in a separate file
 *
 * @param[in] chosen_t The "indices" of tangents to be computed by the run
 * @param[in] tk_expect The accumulated tangent-tangent correlation for @f${\bf t}@f$
 * @param[in] chosen_s The "indices" of arclengths to be computed
 * @param[in] sk_expect The accumulated tangent-tangent correlation for @f${\bf t}@f$
 * definition of tangent
 * @param[in] r_expect The accumulated data for the Flory persistence vectors
 * @param[in] num_configs The number of configurations accumulated so far (needed to
 * divide the accumulated data values)
 * @param[in] file_name_prefix The prefix of the names of files to save the data in
 * @param[in] file_name_suffix The suffix of the names of files to save the data in
 */
void save_data(vector<int> &chosen_t, vector<vector<double> > &tk_expect,
		vector<int> &chosen_s, vector<vector<double> > &sk_expect,
		vector<Vector3D> &r_expect, int num_configs,
		const string &file_name_prefix, const string &file_name_suffix) {

	// Print out expectations of tangent-tangent correlation
	for (int i = 0; i < (int) chosen_t.size(); ++i) {
		stringstream file_name;
		file_name << file_name_prefix << "_t" << chosen_t[i]
				<< file_name_suffix;
		ofstream tk_stream(file_name.str().c_str());
		for (int j = 0; j < (int) tk_expect[i].size(); ++j) {
			tk_stream << j << " " << tk_expect[i][j] / num_configs << endl;
		}
		tk_stream.close();
	}

	// Print out expectations of arclengths
	for (int i = 0; i < (int) chosen_s.size(); ++i) {
		stringstream file_name;
		file_name << file_name_prefix << "_s" << chosen_s[i]
				<< file_name_suffix;
		ofstream sk_stream(file_name.str().c_str());
		interpolate_sk(chosen_s[i], sk_expect[i]);
		for (int j = 0; j < (int) sk_expect[i].size(); ++j) {
			sk_stream << j << " " << sk_expect[i][j] / num_configs << endl;
		}
		sk_stream.close();
	}

	// Print out Flory persistence vectors
	if (!r_expect.empty()) {
		ofstream r_stream((file_name_prefix + "_r" + file_name_suffix).c_str());
		for (int i = 0; i < (int) r_expect.size(); ++i) {
			r_stream << i << " " << r_expect[i] / num_configs << endl;
		}
		r_stream.close();
	}
}

/**
 * The main function of the program that runs the MC simulation. Run without
 * command line arguments to see usage instructions.
 *
 * @param argc The number of command line arguments
 * @param argv The command line arguments
 * @return An error code; 0 - success
 */
int main(int argc, char **argv) {
	int num_configs_gen;
	int num_configs_acc;

	// Measure the running time of the entire simulation
	uint_fast64_t begin_time = get_time();
	double running_time;

    // Storage for dimer stiffness blocks and sigma vectors
    vector<double> dimer_stiff[36];
    vector<double> dimer_shapes[36];
    vector<double> end1_stiff[16];
    vector<double> end1_shapes[16];
    vector<double> end2_stiff[16];
    vector<double> end2_shapes[16];
    
	// Storage for stiffness and shape data of the given sequence
	vector<double> oligo_stiff;
	vector<double> oligo_w_hat;
	//  Storage for
	vector<double> cgDNA_shape;

	// Storage for base pair positions and orientations
	vector<Vector3D> r_bp;
	vector<QuaternionD> R_bp;

	// Storage for tangents
	vector<int> chosen_t;
	vector<vector<Vector3D> > tk;
	// Storage for arclengths
	vector<int> chosen_s;
	vector<vector<double> > sk;
	// Storage for Flory persistence vectors
	bool flory_chosen = false;
	vector<Vector3D> r;

	// Storage for the  expectations
	vector<vector<double> > tk_expect;
	vector<vector<double> > sk_expect;
	vector<Vector3D> r_expect;

	// Options and other helper variables
	int result;
	int num_dropped_bp;
	int num_bp;
       
	// Data for use/don't use Jacobian option
	bool use_jac = false;
	double jac = 1.0;
	double jac_old = 0.0;
    
	// Seed for initializing the random number generator using
	// By default - a value taken from /dev/urandom
	// This might be changed if a seed command line argument is given
	// (see below)
	long seed = get_random_seed();

	int num_accepted = 0;
	bool accept = true;
	int trial;

    string inut_paramset;
	string label;
	string seq;
	string seq_filename;
	string file_suffix;
	string file_suffix_intr;
	stringstream num_configs_strstr;
	stringstream expect_strstr;
	string msg;

    // The stream to open and read the sequence file
    ifstream seq_stream;
    
	// The stream to write the execution log data to
	ofstream log_stream;

	// Get the command line options
	result = handle_command_line(argc, argv, chosen_t, chosen_s, flory_chosen,
			label, seq_filename, inut_paramset, num_configs_gen,
			num_configs_acc, use_jac, num_dropped_bp, seed);

    if (result != 0) {
		return result;
	}

	// Initialize the random number generator with the chosen seed
	init_rand_generator(seed);

	// Create file name suffixes
	file_suffix = get_file_suffix(num_dropped_bp, use_jac, seed, false);
	file_suffix_intr = get_file_suffix(num_dropped_bp, use_jac, seed, true);
	if (num_configs_gen > 0) {
		num_configs_strstr << num_configs_gen << 'g';
	} else {
		num_configs_strstr << num_configs_acc << 'a';
	}

	// Create a list of requested expectations
	for (int i = 0; i < (int) (chosen_t.size()); ++i) {
		expect_strstr << "-t" << chosen_t[i];
	}
	for (int i = 0; i < (int) (chosen_s.size()); ++i) {
		expect_strstr << "-s" << chosen_s[i];
	}
	if (flory_chosen) {
		expect_strstr << "-r";
	}

	// Open a log file and write the bookkeeping information
	log_stream.open(
			(label + expect_strstr.str() + '_' + num_configs_strstr.str() + '_'
					+ file_suffix + ".log").c_str());

	// Expectations to be computed
	log_stream << "Requested expectations:";
	if (!chosen_t.empty()) {
		log_stream << "\n    tang-tan correlations for:";
		for (int i = 0; i < (int) chosen_t.size(); ++i) {
			log_stream << " t^{[" << chosen_t[i] << "]}";
		}
	}
	if (!chosen_s.empty()) {
		log_stream << "\n    arclengths:";
		for (int i = 0; i < (int) chosen_s.size(); ++i) {
			log_stream << " s^{[" << chosen_s[i] << "]}";
		}
	}
	if (flory_chosen) {
		log_stream << "\n    Flory persistence vectors";
	}

	log_stream << "\nConstructing data..." << endl;
    // Read the provided parameter set into sparse symmetric matrix storage
    result = load_cgdna_parameter_set(inut_paramset, dimer_stiff,
                                      dimer_shapes, end1_stiff ,end1_shapes,end2_stiff,end2_shapes);
    
    if (result != 0) {
        return result;
    }
    
    // Verify the command line arguments and initialize everything
    seq_stream.open(seq_filename.c_str());
    if (!seq_stream.good()) {
        cerr << "Couldn't open sequence file: '" << seq_filename << "'" << endl;
        seq_stream.close();
        return 1;
    }
    
    // Read the sequence
    seq_stream >> seq;
    seq_stream.close();
    
    // Build the stiffness matrix K and weighted shape vector c = K * \hat{w}
    result = build_cgdna_stiff_and_sigma(seq, dimer_stiff, dimer_shapes,
                                         end1_stiff,end1_shapes,end2_stiff,end2_shapes, oligo_stiff, oligo_w_hat);
    
    if (result != 0) {
        return result;
    }
    
    
    // Compute the Cholesky decomposition of K and use it to compute \hat{w}
    result = compute_cgdna_chol_stiff_and_w_hat(oligo_stiff, oligo_w_hat);
    
    if (result != 0) {
        return result;
    }

	log_stream << "Parameter Set used: '" << inut_paramset << endl;

	// Get the number of base pairs from the length of the sequence
	num_bp = seq.size();

	// Check if the number of dropped base pairs is reasonable
	if (num_dropped_bp < 0 || num_bp - 2 * num_dropped_bp < 1) {
		log_stream << "Error!\nThe number of bases to drop (" << num_dropped_bp
				<< ") is out of sequence range [0, " << (num_bp - 1) / 2 << "]"
				<< endl;
		log_stream.close();
		return 3;
	}
	log_stream << "DNA sequence:\n" << seq << endl;
	
	if (num_configs_gen > 0) {
		log_stream << "# of configurations to be generated: " << num_configs_gen
				<< endl;
	} else {
		log_stream << "# of configurations to be accepted: " << num_configs_acc
				<< endl;
	}
	log_stream << "Jacobian used: " << (use_jac ? "Y" : "N") << endl;
	log_stream << "# of base pairs to drop from each end: " << num_dropped_bp
			<< endl;
	log_stream << "The seed used: " << seed << endl;

	// Compute intrinsic data (if requested)
	if (!chosen_t.empty() || !chosen_s.empty()) {
		// Compute the data for the intrinsic shape and prepare all data arrays
		reconstructBPVecD(oligo_w_hat, r_bp, R_bp, true);

		// Compute chosen tangents
		tk.resize(chosen_t.size());
		tk_expect.resize(chosen_t.size());
		for (int i = 0; i < (int) chosen_t.size(); ++i) {
			if (chosen_t[i] == 0) {
				compute_t0(num_dropped_bp, R_bp, tk[i]);
			} else if (chosen_t[i] == 1) {
				compute_t1(num_dropped_bp, r_bp, tk[i]);
			} else {
				compute_tk(num_dropped_bp, r_bp, chosen_t[i], tk[i]);
			}
			// Compute the expectations
			tk_expect[i].resize(tk[i].size());
			for (int j = 0; j < (int) tk_expect[i].size(); ++j) {
				tk_expect[i][j] = tk[i][0].dot(tk[i][j]);
			}
		}
		// Compute chosen arclengths
		sk.resize(chosen_s.size());
		for (int i = 0; i < (int) chosen_s.size(); ++i) {
			compute_sk(num_dropped_bp, r_bp, chosen_s[i], sk[i]);
		}
		// Save the final result
		r_expect.resize(0);
		save_data(chosen_t, tk_expect, chosen_s, sk, r_expect, 1, label,
				string("_") + file_suffix_intr);

		// Clean the data
		for (int i = 0; i < (int) chosen_t.size(); ++i) {
			for (int j = 0; j < (int) tk_expect[i].size(); ++j) {
				tk_expect[i][j] = 0.0;
			}
		}
		for (int i = 0; i < (int) chosen_s.size(); ++i) {
			for (int j = 0; j < (int) sk_expect.size(); ++j) {
				sk_expect[i][j] = 0.0;
			}
		}
	}

	// Generate the requested number of configurations
	// and compute the average tangent-tangent correlations for them
	jac_old = 0.0;
	num_accepted = 0;
	log_stream
			<< "\nStarting simulation (# configurations: accepted / generated)"
			<< endl;
	for (trial = 1;
			// If requested number of generated - go all the way to the limit
			((num_configs_gen >= 0) && trial <= num_configs_gen)
			// If requested number of accepted samples - go to limit - 1
			// (num_accepted is the one after last iteration)
					|| ((num_configs_gen < 0) && num_accepted < num_configs_acc);
			++trial) {
		// MOVE
        result = generate_random_move_band(oligo_stiff, oligo_w_hat,
					cgDNA_shape);

		if (result != 0) {
			log_stream << "Couldn't generate configuration after "
					<< num_accepted << " accepted" << endl;
			return result;
		}

		// ACCEPTANCE STEP
		// Compute the Jacobian if requested
		if (use_jac) {
			jac = compute_jacobian(cgDNA_shape);
			// Acceptance based on the configuration if:
			// * the new Jacobian is greater than the previous one or
			// * according to the ratio of the Jacobians
			// Initially jac_old is 0 so that any value of Jacobian will be
			// accepted in the first step
			accept = jac >= jac_old || get_uni_rand_d() <= jac / jac_old;
		}
		// If Jacobian is not used accept every configuration
		else {
			accept = true;
		}

		// A configuration is accepted or the the Jacobian is not used
		// Otherwise the previous values are used again
		if (accept) {
			++num_accepted;

			// Remember the Jacobian for the next step
			jac_old = jac;

			// Reconstruct positions and frames for that configuration
			reconstructBPVecD(cgDNA_shape, r_bp, R_bp, true);

			// Compute tangents
			for (int i = 0; i < (int) chosen_t.size(); ++i) {
				if (chosen_t[i] == 0) {
					compute_t0(num_dropped_bp, R_bp, tk[i]);
				} else if (chosen_t[i] == 1) {
					compute_t1(num_dropped_bp, r_bp, tk[i]);
				} else {
					compute_tk(num_dropped_bp, r_bp, chosen_t[i], tk[i]);
				}
			}
			// Compute arclengths
			for (int i = 0; i < (int) chosen_s.size(); ++i) {
				compute_sk(num_dropped_bp, r_bp, chosen_s[i], sk[i]);
			}
			// Compute Flory vectors
			if (flory_chosen) {
				compute_r(num_dropped_bp, r_bp, R_bp, r);
			}
		}

		// Update the expectation data for tangent-tangent correlations
		tk_expect.resize(chosen_t.size());
		for (int i = 0; i < (int) chosen_t.size(); ++i) {
			tk_expect[i].resize(tk[i].size());
			for (int j = 0; j < (int) tk_expect[i].size(); ++j) {
				tk_expect[i][j] += tk[i][0].dot(tk[i][j]);
			}
		}
		// Update the expectation data for arclengths
		sk_expect.resize(chosen_s.size());
		for (int i = 0; i < (int) chosen_s.size(); ++i) {
			sk_expect[i].resize(sk[i].size());
			for (int j = 0; j < (int) sk_expect[i].size(); ++j) {
				sk_expect[i][j] += sk[i][j];
			}
		}
		// Update expectation data of Flory persistence vectors
		if (flory_chosen) {
			r_expect.resize(r.size());
			for (int j = 0; j < (int) r_expect.size(); ++j) {
				r_expect[j] += r[j];
			}
		}
		// Log progress every 10000 configurations
		if (trial % 10000 == 0) {
			running_time = (get_time() - begin_time) / 1000000.0;
			log_stream << num_accepted << " / " << trial << " (" << running_time
					<< " s)" << endl;

			// Save the result computed so far
			save_data(chosen_t, tk_expect, chosen_s, sk_expect, r_expect, trial,
					label, "_" + num_configs_strstr.str() + "_" + file_suffix);
		}
	}
	// The for loop ended with trial incremented ones extra
	--trial;

	running_time = (get_time() - begin_time) / 1000000.0;
	log_stream << num_accepted << " / " << trial << " (" << running_time
			<< " s)\n" << endl;
	log_stream << "Acceptance rate: " << num_accepted / (double) trial << endl;

	// Save the final result
	save_data(chosen_t, tk_expect, chosen_s, sk_expect, r_expect, trial, label,
			"_" + num_configs_strstr.str() + "_" + file_suffix);

	running_time = (get_time() - begin_time) / 1000000.0;
	log_stream << "Run finished in " << running_time << " s" << endl;

	return 0;
}
